name: ERPNext v15 镜像构建（含跳过/强制更新逻辑）

on:
  push:
    paths:
      - "erpnext15/**"
      - ".github/workflows/erpnext15-build.yml"
  workflow_dispatch:
    inputs:
      force_update:
        description: "手动触发时是否强制更新（true/false），默认 false"
        required: false
        default: "false"
      tag:
        description: "镜像TAG（缺省将用上游版本号，比如 v15.48.4）"
        required: false
      platforms:
        description: "目标平台（默认 linux/amd64,linux/arm64）"
        required: false
        default: "linux/amd64,linux/arm64"
  schedule:
    # 每天 03:20 UTC 定时检查一次（可按需修改/删除）
    - cron: "20 3 * * *"

permissions:
  contents: read
  packages: write

env:
  # ======= 你可以按需修改的默认项 =======
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/erpnext15
  FRAPPE_PATH: https://github.com/frappe/frappe
  FRAPPE_BRANCH: version-15
  # =====================================

jobs:
  build:
    runs-on: ubuntu-latest
    concurrency:
      group: erpnext15-build
      cancel-in-progress: true

    steps:
      - name: 检出仓库
        uses: actions/checkout@v4

      - name: 安装 jq（用于解析 JSON）
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: 登录镜像仓库（默认 GHCR）
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 读取本地配置（FORCE_UPDATE / ERPNEXT_VERSION）
        id: localcfg
        shell: bash
        run: |
          set -euo pipefail
          # 默认值：不强制更新
          FORCE_UPDATE="false"
          LOCAL_VERSION="unknown"

          # 从 workflow_dispatch 输入覆盖 FORCE_UPDATE
          if [[ "${{ github.event.inputs.force_update || '' }}" == "true" ]]; then
            FORCE_UPDATE="true"
          fi

          # 从 erpnext15/.env.example 读取（如果存在这些键）
          if [[ -f "erpnext15/.env.example" ]]; then
            # 读取 FORCE_UPDATE（若配置文件里给了）
            if grep -qE '^FORCE_UPDATE=' erpnext15/.env.example; then
              # 若手动触发传入了 true，则以手动为准；否则用文件值
              if [[ "$FORCE_UPDATE" != "true" ]]; then
                FORCE_UPDATE="$(grep -E '^FORCE_UPDATE=' erpnext15/.env.example | head -n1 | cut -d= -f2 | tr -d '\r' | tr 'A-Z' 'a-z')"
                [[ -z "$FORCE_UPDATE" ]] && FORCE_UPDATE="false"
              fi
            fi
            # 读取 ERPNEXT_VERSION（本地声明的版本号）
            if grep -qE '^ERPNEXT_VERSION=' erpnext15/.env.example; then
              LOCAL_VERSION="$(grep -E '^ERPNEXT_VERSION=' erpnext15/.env.example | head -n1 | cut -d= -f2 | tr -d '\r' )"
              [[ -z "$LOCAL_VERSION" ]] && LOCAL_VERSION="unknown"
            fi
          fi

          echo "FORCE_UPDATE=$FORCE_UPDATE" | tee -a $GITHUB_OUTPUT
          echo "LOCAL_VERSION=$LOCAL_VERSION" | tee -a $GITHUB_OUTPUT

      - name: 获取上游 ERPNext v15 最新版本号（多重兜底）
        id: upstream
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          UPSTREAM_REPO="frappe/erpnext"
          REMOTE_TAG=""

          echo "== 优先方式：GitHub API 拉取 v15.* tags =="
          # 取最多 200 条 tag，然后筛 v15.*，按语义版本排序，取最后一个
          # 使用 GITHUB_TOKEN 提高速率限制
          RESPONSE="$(curl -fsSL -H "Authorization: Bearer ${GH_TOKEN}" \
            "https://api.github.com/repos/${UPSTREAM_REPO}/tags?per_page=200" || true)"
          if [[ -n "$RESPONSE" ]]; then
            REMOTE_TAG="$(echo "$RESPONSE" | jq -r '.[].name' | grep -E '^v15\.' | sort -V | tail -n1 || true)"
          fi

          if [[ -z "$REMOTE_TAG" ]]; then
            echo "== 兜底1：git ls-remote --tags 解析 v15.* =="
            REMOTE_TAG="$(git ls-remote --tags https://github.com/${UPSTREAM_REPO}.git | \
              awk '{print $2}' | sed 's#refs/tags/##' | sed 's/\^{}//' | grep -E '^v15\.' | sort -V | tail -n1 || true)"
          fi

          if [[ -z "$REMOTE_TAG" ]]; then
            echo "== 兜底2：取 version-15 分支最新提交 SHA =="
            REMOTE_SHA="$(git ls-remote https://github.com/${UPSTREAM_REPO}.git refs/heads/version-15 | awk '{print $1}' | head -n1 || true)"
            if [[ -n "$REMOTE_SHA" ]]; then
              REMOTE_TAG="sha-${REMOTE_SHA:0:12}"
            fi
          fi

          if [[ -z "$REMOTE_TAG" ]]; then
            echo "无法获取上游版本号，终止。"
            exit 1
          fi

          echo "REMOTE_TAG=$REMOTE_TAG" | tee -a $GITHUB_OUTPUT

      - name: 决策：是否需要构建
        id: decide
        shell: bash
        run: |
          set -euo pipefail
          FORCE_UPDATE="${{ steps.localcfg.outputs.FORCE_UPDATE }}"
          LOCAL_VERSION="${{ steps.localcfg.outputs.LOCAL_VERSION }}"
          REMOTE_TAG="${{ steps.upstream.outputs.REMOTE_TAG }}"

          SHOULD_BUILD="true"
          REASON=""

          # 规则：
          # 1) 如果本地声明版本 与 上游版本一致：
          #    - FORCE_UPDATE=false -> 跳过
          #    - FORCE_UPDATE=true  -> 仍然构建
          # 2) 如果不一致 -> 构建
          if [[ "$LOCAL_VERSION" == "$REMOTE_TAG" ]]; then
            if [[ "$FORCE_UPDATE" == "true" ]]; then
              SHOULD_BUILD="true"
              REASON="一致但 FORCE_UPDATE=true，执行构建。"
            else
              SHOULD_BUILD="false"
              REASON="一致且 FORCE_UPDATE=false，跳过构建。"
            fi
          else
            SHOULD_BUILD="true"
            REASON="不一致（本地: ${LOCAL_VERSION} / 上游: ${REMOTE_TAG}），执行构建。"
          fi

          echo "SHOULD_BUILD=$SHOULD_BUILD" | tee -a $GITHUB_OUTPUT
          echo "DECISION_REASON=$REASON" | tee -a $GITHUB_OUTPUT

      - name: 输出决策
        run: |
          echo "FORCE_UPDATE=${{ steps.localcfg.outputs.FORCE_UPDATE }}"
          echo "LOCAL_VERSION=${{ steps.localcfg.outputs.LOCAL_VERSION }}"
          echo "REMOTE_TAG=${{ steps.upstream.outputs.REMOTE_TAG }}"
          echo "SHOULD_BUILD=${{ steps.decide.outputs.SHOULD_BUILD }}"
          echo "原因：${{ steps.decide.outputs.DECISION_REASON }}"

      - name: 若跳过则提前结束
        if: ${{ steps.decide.outputs.SHOULD_BUILD == 'false' && (github.event_name != 'workflow_dispatch') }}
        run: |
          echo "跳过构建（非手动触发）。"

      - name: 计算镜像 TAG 与平台
        if: ${{ steps.decide.outputs.SHOULD_BUILD == 'true' || github.event_name == 'workflow_dispatch' }}
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          REMOTE_TAG="${{ steps.upstream.outputs.REMOTE_TAG }}"
          INPUT_TAG="${{ github.event.inputs.tag || '' }}"
          PLATFORMS="${{ github.event.inputs.platforms || '' }}"
          [[ -z "$PLATFORMS" ]] && PLATFORMS="linux/amd64,linux/arm64"

          # 若手动指定 tag 则用输入，否则默认用上游版本号
          FINAL_TAG="$REMOTE_TAG"
          if [[ -n "$INPUT_TAG" ]]; then
            FINAL_TAG="$INPUT_TAG"
          fi

          echo "FINAL_TAG=$FINAL_TAG" | tee -a $GITHUB_OUTPUT
          echo "PLATFORMS=$PLATFORMS" | tee -a $GITHUB_OUTPUT
          echo "IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$FINAL_TAG" | tee -a $GITHUB_OUTPUT

      - name: Base64 编码 erpnext15/app.json → APPS_JSON_BASE64
        if: ${{ steps.decide.outputs.SHOULD_BUILD == 'true' || github.event_name == 'workflow_dispatch' }}
        id: apps
        shell: bash
        run: |
          set -euo pipefail
          if [[ ! -f "erpnext15/app.json" ]]; then
            echo "缺少 erpnext15/app.json"
            exit 1
          fi
          # 校验 JSON 合法
          jq empty erpnext15/app.json
          # 单行 Base64
          echo "APPS_JSON_BASE64=$(base64 -w 0 erpnext15/app.json)" >> $GITHUB_OUTPUT

      - name: 设置 Buildx
        if: ${{ steps.decide.outputs.SHOULD_BUILD == 'true' || github.event_name == 'workflow_dispatch' }}
        uses: docker/setup-buildx-action@v3

      - name: 构建并推送（layered Containerfile）
        if: ${{ steps.decide.outputs.SHOULD_BUILD == 'true' || github.event_name == 'workflow_dispatch' }}
        uses: docker/build-push-action@v6
        with:
          # 直接使用上游 frappe_docker 作为构建上下文
          context: https://github.com/frappe/frappe_docker.git#main
          file: images/layered/Containerfile
          push: true
          platforms: ${{ steps.meta.outputs.PLATFORMS }}
          build-args: |
            FRAPPE_PATH=${{ env.FRAPPE_PATH }}
            FRAPPE_BRANCH=${{ env.FRAPPE_BRANCH }}
            APPS_JSON_BASE64=${{ steps.apps.outputs.APPS_JSON_BASE64 }}
          tags: |
            ${{ steps.meta.outputs.IMAGE }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest-v15

      - name: 构建结果
        if: ${{ steps.decide.outputs.SHOULD_BUILD == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          docker buildx imagetools inspect "${{ steps.meta.outputs.IMAGE }}"
