name: Build ERPNext AIO Image

on:
  push:
    branches: [ main, master ]
    tags: [ 'v*' ]   # 打 v* tag 时也会触发（并自动用该版本）
  workflow_dispatch:
    inputs:
      version:
        description: '版本号（如 15.77.0 或 v15.77.0）。若留空且用 tag 触发，会用 tag；否则将自动发现 upstream 最新版'
        required: false
      force_update:
        description: '是否强制更新（忽略“GHCR 已有同等/更高版本就跳过”的逻辑）'
        type: boolean
        default: false
      push_git_tag:
        description: '构建成功后，把该版本回推为 Git tag（v{version}）'
        type: boolean
        default: true
      force_rebuild:
        description: '强制全量重建（禁用缓存）'
        type: boolean
        default: false
  schedule:
    # 每月 1 号 08:00 UTC（美中区大约凌晨 3 点/2 点）自动检查
    - cron: '0 8 1 * *'

permissions:
  contents: write   # 回推 Git tag/版本文件 需要
  packages: write   # 推 GHCR 需要

concurrency:
  group: erpnext-aio-15-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install jq & curl deps
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # === 发现 upstream ERPNext 最新版本（多路回退） ===
      - name: Discover upstream ERPNext version (multi-source)
        id: upstream
        shell: bash
        run: |
          set -euo pipefail

          # helper: 去掉前缀 v
          trim_v() { sed -E 's/^v//'; }

          INPUT_VER="${{ inputs.version || '' }}"
          REF_TYPE="${GITHUB_REF_TYPE:-''}"
          REF_NAME="${GITHUB_REF_NAME:-''}"

          if [[ -n "${INPUT_VER}" ]]; then
            # 用户手动指定 → 原样使用
            CANDIDATE="${INPUT_VER}"
            SRC="manual-input"
          elif [[ "${REF_TYPE}" == "tag" && -n "${REF_NAME}" ]]; then
            # tag 触发 → 使用该 tag
            CANDIDATE="${REF_NAME}"
            SRC="self-tag"
          else
            SRC=""
            CANDIDATE=""

            echo "::group::Method #1: GitHub Releases (latest)"
            set +e
            REL=$(curl -fsSL "https://api.github.com/repos/frappe/erpnext/releases/latest" 2>/dev/null | jq -r '.tag_name // empty')
            RC=$?
            set -e
            if [[ ${RC} -eq 0 && -n "${REL}" ]]; then
              CANDIDATE="${REL}"
              SRC="github-releases"
              echo "Found via releases: ${CANDIDATE}"
            fi
            echo "::endgroup::"

            if [[ -z "${CANDIDATE}" ]]; then
              echo "::group::Method #2: Git tags (ls-remote + version sort)"
              # 获取所有 v* tag，按版本排序取最大
              ALL=$(git ls-remote --tags --refs https://github.com/frappe/erpnext.git 'v*' \
                    | awk '{print $2}' | awk -F/ '{print $3}' | sort -V | tail -n1 || true)
              if [[ -n "${ALL}" ]]; then
                CANDIDATE="${ALL}"
                SRC="git-tags"
                echo "Found via git tags: ${CANDIDATE}"
              fi
              echo "::endgroup::"
            fi

            if [[ -z "${CANDIDATE}" ]]; then
              echo "::group::Method #3: SourceForge mirror (best-effort scrape)"
              # 粗略抓取 vXX.YY.ZZ 模式，按版本排序
              SF=$(curl -fsSL 'https://sourceforge.net/projects/erpnext.mirror/files/' \
                    | grep -Eo 'v[0-9]+\.[0-9]+\.[0-9]+' | sort -V | tail -n1 || true)
              if [[ -n "${SF}" ]]; then
                CANDIDATE="${SF}"
                SRC="sourceforge"
                echo "Found via sourceforge: ${CANDIDATE}"
              fi
              echo "::endgroup::"
            fi

            if [[ -z "${CANDIDATE}" ]]; then
              echo "::error::无法从多源发现 ERPNext 最新版本"
              exit 1
            fi
          fi

          # 归一化：保存带 v 的原样和去 v 的纯版本
          WITH_V="${CANDIDATE}"
          NO_V="$(echo "${CANDIDATE}" | trim_v)"

          echo "upstream_source=${SRC}"        >> "$GITHUB_OUTPUT"
          echo "upstream_version_raw=${WITH_V}" >> "$GITHUB_OUTPUT"
          echo "upstream_version=${NO_V}"       >> "$GITHUB_OUTPUT"

      # === 决定镜像名与 tags（latest + vX.Y.Z） ===
      - name: Derive image & tags
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/${{ github.repository_owner }}/erpnext15-aio"

          # 统一使用 upstream 发现的版本（或手动/自 tag）
          VER_V="${{ steps.upstream.outputs.upstream_version_raw }}"
          VER="${{ steps.upstream.outputs.upstream_version }}"

          TAGS="${IMAGE}:latest,${IMAGE}:${VER_V}"
          echo "image=${IMAGE}"  >> "$GITHUB_OUTPUT"
          echo "version=${VER}"  >> "$GITHUB_OUTPUT"
          echo "version_with_v=${VER_V}" >> "$GITHUB_OUTPUT"
          echo "tags=${TAGS}"    >> "$GITHUB_OUTPUT"

      # === 查询 GHCR 是否已有同等/更高版本；输出 should_update ===
      - name: Check GHCR existing tags & decide update
        id: decide
        shell: bash
        env:
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          IMAGE_PATH="${{ github.repository_owner }}/erpnext15-aio"
          TARGET_V_V="${{ steps.meta.outputs.version_with_v }}"
          TARGET_V="${{ steps.meta.outputs.version }}"
          FORCE_UPDATE="${{ inputs.force_update == true }}"

          echo "Target version: ${TARGET_V_V}"

          # 列出 GHCR 已有 tags
          set +e
          TAG_JSON=$(curl -fsSL -H "Authorization: Bearer ${GHCR_TOKEN}" \
            "https://ghcr.io/v2/${IMAGE_PATH}/tags/list")
          RC=$?
          set -e
          if [[ ${RC} -ne 0 || -z "${TAG_JSON}" ]]; then
            echo "GHCR tag list unavailable; assume no existing tags."
            echo "should_update=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          mapfile -t TAGS < <(echo "${TAG_JSON}" | jq -r '.tags[]?' )
          if [[ ${#TAGS[@]} -eq 0 ]]; then
            echo "No tags found on GHCR; need update."
            echo "should_update=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 计算 GHCR 已有的“最高版本”（按数字排序；忽略非语义标签如 latest）
          highest=""
          for t in "${TAGS[@]}"; do
            if [[ "${t}" == "latest" ]]; then continue; fi
            t_nv="${t#v}"
            # 必须是 x.y.z
            if [[ "${t_nv}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              highest="${highest}"$'\n'"${t_nv}"
            fi
          done
          if [[ -z "${highest}" ]]; then
            echo "No semver tags on GHCR; need update."
            echo "should_update=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          HIGHEST=$(printf "%s\n" "${highest}" | sort -V | tail -n1)
          echo "GHCR highest: v${HIGHEST}"

          need="false"
          if [[ "${FORCE_UPDATE}" == "true" ]]; then
            need="true"
          else
            # 若 GHCR 已有 >= 目标版本，则跳过；否则需要更新
            # 使用 sort -V 比较
            cmp=$(printf "%s\n%s\n" "${HIGHEST}" "${TARGET_V}" | sort -V | tail -n1)
            if [[ "${cmp}" != "${HIGHEST}" ]]; then
              # 正常不会发生
              need="true"
            else
              if [[ "${HIGHEST}" == "${TARGET_V}" ]]; then
                need="false"
              else
                # GHCR 最高 > 目标 → 说明我们更高了，也无需构建
                need="false"
              fi
            fi
          fi

          echo "should_update=${need}" >> "$GITHUB_OUTPUT"
          if [[ "${need}" == "false" ]]; then
            echo "Skip build: GHCR already has ${HIGHEST} (>= ${TARGET_V}) and force_update is false."
          fi

      # === 如需更新：写入/刷新版本文件并提交（保证仓库有改动，便于可追踪） ===
      - name: Bump version file & commit
        if: ${{ steps.decide.outputs.should_update == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          VER_V="${{ steps.meta.outputs.version_with_v }}"
          echo "${VER_V}" > erpnext15/UPSTREAM_ERPNext_VERSION
          git config user.name  "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          if ! git diff --quiet; then
            git add erpnext15/UPSTREAM_ERPNext_VERSION
            git commit -m "chore: bump upstream ERPNext to ${VER_V}"
            git push
          else
            echo "No repo changes to commit."
          fi

      - name: Build & Push (GHCR)
        if: ${{ steps.decide.outputs.should_update == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: ./erpnext15
          file: ./erpnext15/Dockerfile
          platforms: linux/amd64
          pull: true
          push: true
          no-cache: ${{ inputs.force_rebuild == true }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version_with_v }}
            org.opencontainers.image.revision=${{ github.sha }}

      # === 可选：构建被跳过时也把原因说清楚 ===
      - name: Nothing to do
        if: ${{ steps.decide.outputs.should_update != 'true' }}
        run: echo "No update needed (or force_update=false and GHCR already >= upstream)."

      # === 成功构建才打 Git tag（手动选项，且不是 tag 触发自身） ===
      - name: Create & push git tag (optional)
        if: ${{ steps.decide.outputs.should_update == 'true' && inputs.push_git_tag == true && github.ref_type != 'tag' }}
        shell: bash
        run: |
          set -e
          VER_V="${{ steps.meta.outputs.version_with_v }}"
          git config user.name  "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
          # 避免重复 tag
          if git rev-parse "v${{ steps.meta.outputs.version }}" >/dev/null 2>&1; then
            echo "Git tag already exists: ${VER_V}"
          else
            git tag -a "${VER_V}" -m "Release ${VER_V}"
            git push origin "${VER_V}"
          fi
